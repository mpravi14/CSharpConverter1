group cSharp4;


createClass(classBody)::=<<

/**
 *************************************************************************
 NBCU CONFIDENTIAL
 ___________________
 
 NBCU is a trademark of NBCU Management Company.
 Copyright © 2016 NBCU. All rights reserved.

 NOTICE:  All information contained herein is, and remains
 the property of NBCU and its suppliers, if any.  
 The intellectual and technical concepts contained
 herein are proprietary to NBCU and its suppliers and may be 
 covered by U.S. and Foreign Patents, patents in process, 
 and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from NBCU. 

************************************************************************
 Author           : Generated by ATMA ®
 Revision History : 
*/

<classBody>

>>


writeFormerClass(originalMember)::=<<
<originalMember>

>>

spaceIterator(list)::=<<
<list; separator=" ">
>>

text(value)::="<value>"

usingStatement(resourceAcq,body)::=<<

<resourceAcq>
<body>


>>

resourceAcquisition(stmt)::=<<
<stmt>
>>

importStmts(lstImports)::=<<

>>

importStmt(packName,comments)::=<<
import <packName>;<if(comments)><comments><endif>
>>

writeCompUnit(alisDRctv,imports,gas,nmspMemDec)::=<<
<alisDRctv>
<imports>
<gas>
<nmspMemDec>
>>

pkgDeclarationandClassBody(packageName,nameSpaceBody,deleimiter,comments)::=<<
package <packageName>;

import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.apache.log4j.Logger;

import com.nbcu.campus.server.service.impl.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import com.nbcu.compass.shared.dataobject.*;

<nameSpaceBody><if(deleimiter)><deleimiter><endif><if(comments)><comments><endif>
>>


pkgDeclChld(root,chldLst)::=<<
<root><chldLst>
>>

typeArgumentList(arguments)::=<<
\<<arguments>\>
>>

classDefinition(className,baseClass,comments1,classBody,delimiter,comments)::=<<
class <className> <baseClass><if(comments)><comments><endif>
<classBody><if(delimiter)><delimiter><endif><if(comments)><comments><endif>
>>

typeDeclaration(attributes,comments,accessModifiers,bodyDefintion)::=<<
<if(attributes)><attributes><endif> <if(comments)><comments><endif> 
<if(accessModifiers)><accessModifiers><endif> <bodyDefintion>
>>

typeDeclarationChld(decl)::=<<
<decl>
>>

namespaceOrTypeName(firstPart,argList,secondPart)::=<<
<firstPart><if(argList)><argList><endif><if(secondPart)><secondPart><endif>
>>

namespaceOrTypeName2(firstPart,secondPart)::=<<
<firstPart> <secondPart; separator="\n">
>>

createClassBody(alisDRctv,imports,gas,nmspMemDec)::=<<
<alisDRctv>
<imports>

<nmspMemDec>

>>

namespaceOrTypeNameChld(identifier,argumentList)::=<<
.<identifier> <if(argumentList)><argumentList><endif>
>>

classBase(parentClass,classBody)::=<<
<parentClass>  <classBody; separator="\n">
>>

classBody(classMemdeclarations)::=<<
{

<if(classMemdeclarations)><classMemdeclarations><endif>
}

>>

classMemberDeclarations(classMembersList)::=<<
<if(classMembersList)><classMembersList; separator="\n"><endif>
>>

classMemberDeclaration(attributes,accessModifiers,comMemDec,methodName)::=<<
@RequestMapping(value = "/<methodName>", method = RequestMethod.POST)
<if(attributes)><attributes><endif><if(accessModifiers)><accessModifiers><endif> @ResponseBody <if(comMemDec)><comMemDec><endif>
>>

attributes(value)::=<<
<value>
>>

attribute(attributeName,attributeArgs)::=<<
<attributeName> (<if(attributeArgs)><attributeArgs><endif>)
>>

attributeSection(attributeTargetSpecifier,attributeList,separtr)::=<<
[<attributeTargetSpecifier> <attributeList> <if(separtr)><separtr><endif>]
>>
 
attributeList(firstAttribute,attributeList)::=<<
<firstAttribute><if(attributeList)><attributeList><endif>
>>

attributeArguments(positionalArgumentList)::=<<
<if(positionalArgumentList)><positionalArgumentList><endif>
>>

positionalArgumentList(firstArg,restArgsLst)::=<<
<firstArg><if(restArgsLst)><restArgsLst><endif>
>>

positionalArgument(attributeArgExpr)::=<<
<attributeArgExpr>
>>

attributeArgumentExpression(expr)::=<<
<expr>
>>

expression(assignment)::=<<
<strip(assignment)>
>>

assignment(unaryExpr,operator,expression)::=<<
<unaryExpr> <if(expression)><operator> <expression><endif>
>>

unaryExpression(value)::=<<
<strip(value)>
>>

scanForCastGenericPrecedence(type,castDisAmbTok)::=<<
(<type>) <castDisAmbTok>
>>

castExpression(type,unaryExpr)::=<<
(<type>) <unaryExpr>
>>

commonMemberDeclaration(arg1,arg2)::=<<
<if(arg1)><arg1><endif> <if(arg2)><arg2><endif>
>>

constructorDeclaration2(constrName,formalParamLst,constrInit,constrBdy)::=<<
<constrName><if(formalParamLst)><formalParamLst><endif> <if(constrInit)><constrInit><endif><constrBdy>
>>

parameterArray(atbts,param,idName)::=<<
<atbts> <param> <idName>
>>

block(comments,blockStmtLst)::=<<
{
<if(comments)><comments><endif><if(blockStmtLst)><blockStmtLst><endif>
}

>>

allMemberModifier(value)::=<<
<if(value)><value><endif>
>>

statement(stmt)::=<<
<if(stmt)><stmt><endif>
>>

labeledStatement(labelName,labelBody)::=<<
<labelName> : <labelBody>
>>

declarationStatement(variableDecl,comments)::=<<
<strip(variableDecl)><if(comments)><comments><endif>;
>>

localVariableDeclaration(varType,declarators)::=<<
<varType> <declarators>
>>

localVariableType(type)::=<<
<type>
>>

localVariableDeclarators(firstDeclaration,declarationChld)::=<<
<firstDeclaration> <declarationChld; separator=" ">
>>

localVariableDeclaratorsChld(localVarDec)::=<<
,<localVarDec>
>>

localVariableDeclarator(lvdName,localVarInit)::=<<
<lvdName>  <if(localVarInit)>=<localVarInit><endif>
>>

localVariableInitializer(init)::=<<
<init>
>>

arrayInitializer(varInitList)::=<<
<varInitList>
>>

variableInitializerList(varIni,list)::=<<
<varIni> <list; separator=" ">
>>

variableInitializerListChld(init)::=<<
,<init>
>>

localVariableInitializerUnsafe(init)::=<<
<init>
>>

localConstantDeclaration(type,constDecls)::=<<
<type> <constDecls>
>>

constantDeclarators(firstDecl,list)::=<<
<firstDecl> <list; separator=" ">
>>

constantDeclaratorsChld(constDecl)::=<<
,<constDecl>
>>

body(value)::=<<
<value>
>>

statementList(list)::=<<
<if(list)><list; separator="\n"><endif>
>>

embeddedStatement(stmt)::=<<
<stmt>
>>

emptyStatement(value,comments)::=<<
<value><comments>
>>

expressionStatement(statement,comments)::=<<
<if(statement)><strip(statement)><endif>;<if(comments)><comments><endif>
>>

iterationStatement(stmt)::=<<
<stmt>
>>

whileStatement(condition,body)::=<<
while(<condition>){
<body>
}

>>

doStatement(doBody,condition,comments)::=<<

do{
<doBody>
}while(<condition>)<if(comments)><comments><endif>;

>>

forStatement(initialization,condition,iterator,forBody)::=<<
for(<if(initialization)><initialization><endif>;<if(condition)><condition><endif>;<if(iterator)><iterator><endif>){
<forBody>
}

>>

foreachStatement(variableType,variable,expression,forEachBody,comment)::=<<
for(<variableType> <variable> : <expression>){
<forEachBody>
}
<if(comment)><comment><endif>
>>

jumpStatement(stmt)::=<<
<stmt>
>>

simpleGotoStatement(labelName,comments)::=<<
goto <strip(labelName)>; <if(comments)><comments><endif>
>>

gotoDefaultStmt(comments)::=<<
goto default; <if(comments)><comments><endif>
>>

constantExpression(expression)::=<<
<expression>
>>

gotoCaseStmt(caseExpr,comments)::=<<
goto case <caseExpr>; <if(comments)><comments><endif>
>>

returnStatement(returnExpr,comments)::=<<
return <strip(returnExpr)>; <if(comments)><comments><endif>
>>

throwStatement(throwExpr,comments)::=<<
throw <strip(throwExpr)>; <if(comments)><comments><endif>
>>

methodDeclaration2(methodName,typeParamLst,formalParamLst,paramClauses,commnents,methodBody)::=<<
<methodName><if(typeParamLst)><typeParamLst><endif>(<if(formalParamLst)>@RequestBody  <formalParamLst><endif>)<if(paramClauses)><paramClauses><endif><if(commnents)><commnents><endif><if(methodBody)><methodBody><endif>
>>

methodMemberName(methodName)::=<<
<methodName>
>>

methodMemberName2Chld(typArglst,endId)::=<<
<if(typArglst)><typArglst><endif>.<endId>
>>

methodMemberName2(startId,list)::=<<
<startId><if(list)><list><endif>
>>

methodBody(body,comments)::=<<
<body><if(comments)><comments><endif>
>>

booleanExpression(boolExpr)::=<<
<boolExpr>
>>

primaryExpressionStart(expression)::=<<
<strip(expression)>
>>

primaryExpressionStartChld(type,expression)::=<<
new <if(type)><strip(type)><endif><expression>
>>

primaryExpressionStartChld2(anyObjInit)::=<<
new <strip(anyObjInit)>
>>

primaryExpressionStartChld3(rnkSpcr,arrInit)::=<<
new <strip(rnkSpcr)> <strip(arrInit)>
>>

primaryExpressionStartSubChld(expr)::=<<
<strip(expr)>
>>

primaryExpressionStartSubChld2(exprList,rnkSpecfr,arryInit)::=<<
(<strip(exprList)>) <if(rnkSpecfr)><strip(rnkSpecfr)><endif> <if(arryInit)><strip(arryInit)><endif>
>>

primaryExpressionStartSubChld3(expr1,expr2)::=<<
<strip(expr1)> <strip(expr2)>
>>

expressionListPrimaryExprChld(exprLst,rnkSpecifier,arrayInitialization)::=<<
<exprLst><if(rnkSpecifier)><rnkSpecifier><endif><if(arrayInitialization)><arrayInitialization><endif>
>>

objectCreationExpression2(argumentList,init)::=<<
(<if(argumentList)><argumentList><endif>)<if(init)><init><endif>
>>

objectOrCollectionInitializer(init)::=<<
<strip(init)>
>>

objectInitializer(memInitList)::=<<
<memInitList>
>>

memberInitializerListChld(memInit)::=<<
,<memInit>
>>

memberInitializerList(firstInit,list)::=<<
<firstInit><if(list)><list><endif>
>>


memberInitializer(memberName,initVal)::=<<
<memberName> <if(initVal)>=<initVal><endif>
>>

initializerValue(expression)::=<<
<expression>
>>

primaryExpression(prmExprStrt,frstBrktExpr,prmChldLst)::=<<
<prmExprStrt><if(frstBrktExpr)><frstBrktExpr><endif><if(prmChldLst)><prmChldLst><endif>
>>

primaryExpressionChld(peChild,bracketExpr)::=<<
<peChild><if(bracketExpr)><bracketExpr><endif>
>>

primaryExpressionSubChld(expressionChild)::=<<
<expressionChild>
>>

primaryExpressionSubChld2(expressionChildprt1,expressionChildprt2)::=<<
<expressionChildprt1><expressionChildprt2>
>>

typedMemberDeclaration(type,typeDecl,body1,body2)::=<<
<if(body1)> <typeDecl><else><type> <body2><endif>
>>

typedMemberDeclarationForPropDecl(type,propDeclName,body)::=<<
private <body>;
public <type> get<propDeclName>{
    return <body>;
}

public <type> set<propDeclName>(<type> <body>){
    this.<body>=<body>;
}

>>

anonymousObjectInitializer(memDeclLst)::=<<
{
<if(memDeclLst)><memDeclLst><endif>
}

>>

memberDeclaratorList(memberDecl,list)::=<<
<memberDecl><if(list)><list><endif>
>>

memberDeclaratorListChld(decl)::=<<
,<decl>
>>

memberDeclarator(expression)::=<<
<if(expression)><expression><endif>
>>

bracketExpression(expressionList)::=<<
<expressionList>
>>

expressionList(firstExpr,list)::=<<
<firstExpr><if(list)><list><endif>
>>

expressionListChld(expression)::=<<
,<expression>
>>

memberAccess2(memName,argLst)::=<<
.<memName><if(argLst)><argLst><endif>
>>

methodInvocation2(argLst)::=<<
(<if(argLst)><strip(argLst)><endif>)
>>

dattype(firstType,list)::=<<
<strip(firstType)> <if(list)><list><endif>
>>

nonAssignmentExpression(expression)::=<<
<if(expression)><expression><endif>
>>

statementExpression(expression)::=<<
<if(expression)><expression><endif>
>>

selectionStatement(stmt)::=<<
<stmt>
>>

typeArgumentListOpt(argList)::=<<
<argList>
>>

formalParameterList(fixedParams,list)::=<<
<if(fixedParams)><fixedParams><endif><list>
>>

formalParameterListChld(params)::=<<
,<strip(params)>
>>

fixedParameters(firstParam,list)::=<<
<firstParam><if(list)><list><endif>
>>

fixedParametersChld(param)::=<<
,<strip(param)>
>>

fixedParameter(attributes,paramModifier,dataType,paramName,defaultArgs)::=<<
<if(attributes)><attributes><endif><if(paramModifier)><paramModifier><endif><dataType> <paramName><if(defaultArgs)><defaultArgs><endif>
>>

fixedParameter2(argumentList)::=<<
<argumentList>
>>


literal(ltrl)::=<<
<ltrl>
>>

booleanLiteral(value)::=<<
<value>
>>

typedMemberDeclarationChld(declaration)::=<<
<declaration>
>>

fieldDeclaration2(declaration,comments)::=<<
<strip(declaration)><if(comments)><comments><endif>;
>>

variableDeclarators(firstDecl,list)::=<<
<firstDecl><if(list)><list><endif>
>>

variableDeclaratorsChld(decl)::=<<
,<strip(decl)>
>>

variableDeclarator(value)::=<<
<value>
>>

variableDeclarator2(lhs,rhs)::=<<
<lhs><if(rhs)>=<rhs><endif>
>>

multiplicativeExpression(lhs,rhs)::=<<
<lhs> <if(rhs)><rhs><endif>
>>

multiplicativeExpressionChld(optr,rhs)::=<<
<optr> <strip(rhs)>
>>

variableInitializer(init)::=<<
<strip(init)>
>>

conditionalExpression(lhs,optr1,optr2,expr1,expr2)::=<<
<strip(lhs)><if(expr1)><optr1><expr1><optr2><expr2><endif>
>>

nullCoalescingExpression(lhs,optr,rhs)::=<<
<lhs><if(rhs)><optr> <strip(rhs)><endif>
>>

conditionalOrExpression(lhs,rhs)::=<<
<lhs> <if(rhs)><strip(rhs)><endif>
>>

conditionalOrExpressionChld(optr,rhs)::=<<
<optr> <strip(rhs)>
>>

conditionalAndExpression(lhs,rhs)::=<<
<lhs> <if(rhs)><strip(rhs)><endif>
>>

conditionalAndExpressionChld(optr,rhs,comments)::=<<
<optr> <strip(rhs)>
<if(comments)><comments><endif>
>>

inclusiveOrExpression(lhs,rhs)::=<<
<lhs><if(rhs)><strip(rhs)><endif>
>>

inclusiveOrExpressionChld(optr,rhs)::=<<
<optr> <strip(rhs)>
>>

exclusiveOrExpression(lhs,rhs)::=<<
<lhs> <strip(rhs)>
>>

exclusiveOrExpressionChld(optr,rhs)::=<<
<optr> <strip(rhs)>
>>

andExpression(lhs,rhs)::=<<
<lhs> <if(rhs)><strip(rhs)><endif>
>>

andExpressionChld(optr,rhs)::=<<
<optr> <strip(rhs)>
>>

equalityExpression(lhs,rhs)::=<<
<lhs> <if(rhs)><strip(rhs)><endif>
>>

equalityExpressionChld(optr,rhs)::=<<
<optr> <strip(rhs)>
>>

relationalExpression(lhs,rhs)::=<<
<lhs> <if(rhs)><strip(rhs)><endif>
>>

relationalExpressionChld(optr,rhs)::=<<
<optr> <strip(rhs)>
>>

shiftExpression(lhs,rhs)::=<<
<lhs> <if(rhs)><strip(rhs)><endif>
>>

shiftExpressionChld(optr,rhs)::=<<
<optr> <strip(rhs)>
>>

additiveExpression(lhs,rhs)::=<<
<lhs> <if(rhs)><strip(rhs)><endif>
>>

additiveExpressionChld(optr,rhs)::=<<
<optr> <strip(rhs)>
>>

simpleName(name,argList)::=<<
<name><if(argList)><argList><endif>
>>

argumentList(firstArgmnt,list)::=<<
<firstArgmnt> <list>
>>

argumentListChld(args)::=<<
,<args>
>>

argument(argName,argValue)::=<<
<if(argName)><argName><endif><argValue>
>>

argumentName(id)::=<<
<id>
>>

argumentValue(value)::=<<
<value>
>>

argumentValue2(type,value)::=<<
<type> <value>
>>

variableReference(ref)::=<<
<ref>
>>

objectCreationExpression(type,child)::=<<
<type><if(child)><child><endif>
>>

objectCreationExpressionChld(argLst,init)::=<<
(<if(argLst)><argLst><endif>)<if(init)><init><endif>
>>

parenthesizedExpression(expression)::=<<
(<expression>)
>>

qualifiedAliasMember(actName,aliasName,argList)::=<<
<actName> as <aliasName> <argList>
>>

rankSpecifier(separatorLst)::=<<
[<separatorLst>]
>>

dimSeparators(list)::=<<
, <if(list)><list><endif>
>>

anonymousObjectCreationExpression(anyObjInit)::=<<
new <anyObjInit>
>>

genericDimensionSpecifier(cList)::=<<
<cList>
>>

commas(list)::=<<
,<if(list)><list><endif>
>>

preIncrementExpression(optr,expression)::=<<
<optr><expression>
>>

preDecrementExpression(optr,expression)::=<<
<optr><expression>
>>

isType(type,opt)::=<<
<type><opt>
>>

typeParameterList(paramList)::=<<
<paramList>
>>

typeParametersChld(attributes,param)::=<<
,<if(attributes)><attributes><endif><param>
>>

typeParameters(attr,type,chldList)::=<<
<attr><type><if(chldList)><chldList><endif>
>>

typeName(value)::=<<
<value>
>>

typeChld(value)::=<<
<value>
>>

namespaceName(value)::=<<
<value>
>>

baseType(type)::=<<
<type>
>>

simpleType(type)::=<<
<type>
>>

numericType(type)::=<<
<type>
>>

nullableType(value,kwd)::=<<
<value> <kwd>
>>

classType(value)::=<<
<value>
>>

interfaceType(value)::=<<
<value>
>>

typeArguments(firstArg,chldLst)::=<<
<strip(firstArg)><if(chldLst)><strip(chldLst)><endif>
>>

typeArgumentsChld(args)::=<<
,<args>
>>

typeArgument(value)::=<<
<value>
>>

memberAccess(expr)::=<<
<expr>
>>

collectionInitializer(elementList)::=<<
<elementList>
>>

elementInitializerListChld(init)::=<<
,<init>
>>

elementInitializerList(firstElement,chldList)::=<<
<firstElement><if(chldList)><chldList><endif>
>>

elementInitializer(expression)::=<<
<expression>
>>

arrayCreationExpression(Chld)::=<<
new <Chld>
>>

arrayCreationExpressionChld(subChld)::=<<
<subChld>
>>

arrayCreationExpressionSubChld(arryType,arInit)::=<<
<arryType><arInit>
>>

arrayCreationExpressionChld2(type,expList,rnkSpcr,arrInitlr)::=<<
<if(type)><type><endif>(<expList>)<if(rnkSpcr)><rnkSpcr><endif><if(arrInitlr)><arrInitlr><endif>
>>

arrayCreationExpressionChld3(rnkSpcr,aryInit)::=<<
<rnkSpcr><aryInit>
>>

arrayTypeChld(symbolLst,rnkSpcr)::=<<
<if(symbolLst)><symbolLst><endif><rnkSpcr>
>>

arrayType(type,chldLst)::=<<
<type><if(chldLst)><chldLst><endif>
>>

nonArrayType(type,rankSpcr)::=<<
<type><if(rankSpcr)><rankSpcr><endif>
>>

nonArrayTypeChld(chld)::=<<
<chld>
>>

comment(content)::=<<
<if(content)><content><endif>
>>

comments(list)::=<<
/*<if(list)><list; separator="\n"><endif>*/
>>

getContextualKeyword(value)::=<<
<value>
>>

setContextualKeyword(value)::=<<
<value>
>>

propertyDeclaration(attributes,propModfs,typ,memName,accessDecls)::=<<
<if(attributes)><attributes><endif><if(propModfs)><propModfs><endif><typ><memName><accessDecls>
>>

propertyModifiers(list)::=<<
<if(list)><list><endif>
>>

memberName(type)::=<<
<type>
>>

accessorDeclarations(attributes,acsModfs,body,ck1,ck2)::=<<
<if(attributes)><attributes><endif><if(acsModfs)><acsModfs><endif><ck1><body><if(ck2)><ck2><endif>
>> 

getAccessorDeclaration(attrs,accsModfs,ck,body)::=<<
<if(attrs)><attrs><endif><if(accsModfs)><accsModfs><endif><ck><body>
>>

setAccessorDeclaration(attrs,accsModfs,ck,body)::=<<
<if(attrs)><attrs><endif><if(accsModfs)><accsModfs><endif><ck><body>
>>

accessorBody(body)::=<<
<body>
>>

propertyDeclaration2(mNm,ad1)::=<<
<mNm><ad1>
>>

ifStatement(condition,ifBody,elseBody,comment)::=<<
if(<strip(condition)>){
<ifBody>
}<if(elseBody)>else {
<elseBody>
}<endif>
<if(comment)><comment><endif>
>>

queryExpression(fromClause,body)::=<<
);(<strip(fromClause)> <strip(body)>
>>

fromClause(keyWrd,type,als,expression)::=<<
List\<<if(type)><type><endif> <expression>\>  <als>List = new LinkedList\<<expression>\>();
>>

queryBody(bodyClauses,selectOrGrpCls,quryCond)::=<<
<if(bodyClauses)><strip(bodyClauses)><endif><strip(selectOrGrpCls)><if(quryCond)><strip(quryCond)><endif>
>>

queryBodyClauses(list)::=<<
<if(list)><list><endif>
>>



queryBodyClause(clause)::=<<
<clause>
>>

selectOrGroupClause(clause)::=<<
<clause>
>>

selectClause(keyWrd,expression)::=<<
for(var temp:tempList){
.add(<expression>);
}
>>

groupClause(groupkeyWrd,expression1,byKeyWrd,expression2)::=<<
<groupkeyWrd><strip(expression1)><strip(byKeyWrd)><strip(expression2)>
>>

orderingsChld(ordrng)::=<<
<strip(ordrng)>
>>

orderings(firstOrdrng,list)::=<<
<firstOrdrng><if(list)><strip(list)><endif><endif>
>>

orderbyClause(keyWord,ordngs)::=<<
Collections<ordngs>;
>>

combinedJoinClause(type,joinId,expression1,expression2,expression3,intoId)::=<<

List\<<expression1>\> <if(type)><type><endif> <joinId>List = new LinkedList\<<expression1>\>(); 
for(var <joinId>:<joinId>List){
  if((<expression2>).equals(<expression3>)){
    tempList.add(<joinId>List);
    } 
}
 <if(intoId)> into <intoId><endif>
>>

joinIntoClause(joinKeyWrd,type,joinId,expression1,onKeyWrd,expression2,equalsKeyWrd,expression3,intoId)::=<<
<if(joinKeyWrd)><strip(joinKeyWrd)> <type><endif> <joinId> in <expression1> on <expression2> <equalsKeyWrd> <expression3> into <intoId>
>>

joinClause(type,joinId,expression1,expression2,expression3)::=<<
join <if(type)><type><endif> <joinId> in <expression1> on <expression2> equals <expression3>
>>

whereClause(whereKeyWrd,expression)::=<<
<whereKeyWrd> <expression>
>>

letClause(letKeyWrd,name,expression)::=<<
<letKeyWrd> <name> <expression>
>>

ordering(expression,direction)::=<<
<if(direction)><direction>(<expression>)<else><expression><endif>
>>

orderingDirectionAsc()::=<<
.sort
>>

orderingDirectionDesc()::=<<
.reverse
>>

queryContinuation(intoKeyWrd,name,queryBody)::=<<
<intoKeyWrd> <name> <queryBody>
>>

anonymousFunctionBody(body)::=<<
<body>
>>

implicitAnonymousFunctionParameterListChld(parameter)::=<<
,<parameter>
>>

implicitAnonymousFunctionParameterList(firstPar,list)::=<<
<firstPar><if(list)><list><endif>
>>

implicitAnonymousFunctionSignature(paramList)::=<<
(<paramList>)
>>

implicitAnonymousFunctionSignature2(param)::=<<
<param>
>>

explicitAnonymousFunctionParameter(modifier,type,name)::=<<
<if(modifier)><modifier><endif> <type> <name>
>>

explicitAnonymousFunctionParameterList(firstPar,list)::=<<
<firstPar><if(list)><list><endif>
>>

explicitAnonymousFunctionParameterListChld(parameter)::=<<
,<parameter>
>>

explicitAnonymousFunctionSignature(list)::=<<
(<list>)
>>

anonymousFunctionSignature(list)::=<<
<list>
>>

anonymousFunctionSignature2(parameter)::=<<
<parameter>
>>

anonymousMethodExpression(signature,body)::=<<
delegate <signature> <body>
>>

lambdaExpression(signature,body)::=<<
<signature> => <body>
>>

constantDeclaration2(type,declarators,comments)::=<<
final <type> <strip(declarators)>; <if(comments)><comments><endif>
>>

fixedSizeBufferModifiers(modfs)::=<<
 <if(modfs)><modfs><endif>
>>

primaryNoArrayCreationExpressionUnsafe(expression)::=<<
<expression>
>>

unmanagedType(type)::=<<
<type>
>>

globalAttributeSections(sections)::=<<
<sections>
>>

globalAttributes(attributes)::=<<
<attributes>
>>

breakStatement(value,comments)::=<<
<value><if(comments)><comments><endif>
>>

continueStatement(value,comments)::=<<
<value><if(comments)><comments><endif>
>>

interfaceIndexerDeclaration2(frmlParLst,accessors)::=<<
this[<frmlParLst>](<accessors>)
>>

interfaceEventDeclaration2(type,eventName)::=<<
event <type> <eventName>;
>>

interfacePropertyDeclaration2(name,accessors)::=<<
<name>(<accessors>)
>>

interfaceMethodDeclaration2(methodName,paramList,formlParLst,constraintCls)::=<<
<methodName><if(paramList)><paramList><endif>{<formlParLst>}<if(constraintCls)><constraintCls><endif>
>>

operatorDeclaration2(firstOptr,overloadableOptr,type,typeNam,type2,typeNam2,OptrBody)::=<<
<firstOptr><overloadableOptr>{<type><typeNam><if(type2)>,<type2><typeNam2><endif>}<OptrBody>
>>

eventDeclaration2(type,evntDeclChld)::=<<
event <type> <evntDeclChld>
>>

eventDeclaration2Chld(declaration)::=<<
<declaration>
>>

eventDeclaration2Chld2(memberName,accsDecl)::=<<
<memberName> <accsDecl>
>>

delegateDefinition(retType,retVal,varTypeParLst,formlParLst,constrntCls)::=<<
delegate <retType> <retVal> <if(varTypeParLst)><varTypeParLst><endif> {<if(formlParLst)><formlParLst><endif>} <if(constrntCls)><constrntCls><endif>;
>>


enumDefinition(name,base,body,delimiter)::=<<
enum <name> <if(base)><base><endif><body> <if(delimiter)><delimiter><endif>
>>

interfaceDefinition(kwd,interfaceName,varTypLst,intfcBdy,constrntCls,body,delimiter)::=<<
<kwd><interfaceName><if(varTypLst)><varTypLst><endif><if(intfcBdy)><intfcBdy><endif><if(constrntCls)><constrntCls><endif><body><if(delimiter)><delimiter><endif>
>>

structDefinition(structName,typParLst,strctIntfc,typParConstCls,body,delimiter)::=<<
struct <structName> <if(typParLst)><typParLst><endif> <if(typParConstCls)><typParConstCls><endif> <body> <if(delimiter)><delimiter><endif>
>>

stackallocInitializer(umManTyp,expression)::=<<
stackalloc <umManTyp> [<expression>]
>>

fixedSizeBufferDeclarator(name,expression)::=<<
<name> [<expression>]
>>

fixedSizeBufferDeclarators(declarators)::=<<
<if(declarators)><declarators ><endif>
>>

bufferElementType(type)::=<<
<type>
>>

fixedSizeBufferDeclaration(attributes,fxdSzBufModf,bufElmntTyp,fxdSzBufDcls)::=<<
<if(attributes)><attributes><endif><if(fxdSzBufModf)><fxdSzBufModf><endif> fixed <bufElmntTyp> <fxdSzBufDcls>;
>>

structMemberDeclarationUnsafe(decl)::=<<
<decl>
>>

fixedPointerInitializer(init)::=<<
<init>
>>

fixedPointerDeclarator(lhs,rhs)::=<<
<lhs> = <rhs>
>>

fixedPointerDeclaratorsChld(decl)::=<<
,<decl>
>>

fixedPointerDeclarators(firstDecl,list)::=<<
<firstDecl> <if(list)><list><endif>
>>

fixedStatement(type,ptrDecl,stmts)::=<<
fixed {<type> <ptrDecl>} <stmts>
>>

sizeofExpression(type)::=<<
sizeof {<type>}
>>

addressofExpression(expression)::=<<
& <expression>
>>

pointerIndirectionExpression(expression)::=<<
* <expression>
>>

unaryExpressionUnsafe(expression)::=<<
<expression>
>>

unsafeStatement(block)::=<<
<block>
>>

embeddedStatementUnsafe(stmt)::=<<
<stmt>
>>

staticConstructorModifiersUnsafe(fstKwd,secndKwd)::=<<
<if(fstKwd)><fstKwd><endif><secndKwd>
>>

lineIterator(list)::=<<
<if(list)><list; separator="\n"><endif>
>>

interfaceDeclaration(attributes,intFcModfs,partialKwd,interfaceName,varTypParLst,intfcBas,typParConstCls,intfcBody,delimiter)::=<<
<if(attributes)><attributes><endif><if(intFcModfs)><intFcModfs><endif><if(partialKwd)><partialKwd><endif><interfaceName><if(varTypParLst)><varTypParLst><endif><if(intfcBas)><intfcBas><endif><if(typParConstCls)><typParConstCls><endif><intfcBody><if(delimiter)><delimiter><endif>
>>

interfaceModifiers(list)::=<<
<if(list)><list ><endif>
>>

interfaceIndexerDeclaration(attributes,newKwd,type,formlParLst,accs)::=<<
<if(attributes)><attributes><endif> <if(newKwd)><newKwd><endif> <type> this[ <formlParLst> ] ( <accs> )
>>

interfaceEventDeclaration(attributes,newKwd,type,evntName)::=<<
<if(attributes)><attributes><endif> <if(newKwd)><newKwd><endif> event <type> <evntName>;
>>

interfaceAccessors(attributes)::=<<
<if(attributes)><attributes><endif>
>>

interfacePropertyDeclaration(attributes,newKwd,type,propName,intfcAccrs)::=<<
<if(attributes)><attributes><endif> <if(newKwd)><newKwd><endif> <type> <propName> ( <intfcAccrs> )
>>

interfaceMethodDeclaration(attributes,newKwd,type,methdNam,typParLst,fprmlParLst,typParConstCls)::=<<
<if(attributes)><attributes><endif> <if(newKwd)><newKwd><endif> <type> <methdNam> <if(typParLst)><typParLst><endif> ( <if(fprmlParLst)><fprmlParLst><endif> ) <typParConstCls>; 
>>

interfaceBody(members)::=<<
{<if(members)><members><endif>}
>>

interfaceMemberDeclarations(list)::=<<
<if(list)><list; separator="\n"><endif>
>>

interfaceBase(intfcTypLst)::=<<
extends <intfcTypLst>
>>

indexerDeclaration2(formlParLst,accsDecls)::=<<
this [<formlParLst>]{<accsDecls>}
>>

interfaceMemberDeclaration(com,attributes,com1,newKwd,child)::=<<
<if(com)><com><endif> <if(attributes)><attributes><endif> <if(com1)><com1><endif> <if(newKwd)><newKwd><endif> 
<child>

>>

interfaceMemberDeclarationChld(type,subChild)::=<<
<type> <subChild>
>>

interfaceMemberDeclarationChld2(memNam,typParLst,formlParLst,typParConstCls)::=<<
void <memNam><if(typParLst)><typParLst> <endif>(<if(formlParLst)><formlParLst><endif>)<typParConstCls>;
>>

interfaceMemberDeclarationChld3(type, evntName)::=<<
event <type> <evntName>;
>>

interfaceMemberDeclarationSubChld(memName,typParLst,formlParLst,typParConstrCls)::=<<
<memName> <if(typParLst)><typParLst><endif>(<if(formlParLst)><formlParLst><endif>)<typParConstrCls>;
>>

interfaceMemberDeclarationSubChld2(memName,accrs)::=<<
<memName>{<accrs>}
>>

interfaceMemberDeclarationSubChld3(formlParLst,intfcAccrs)::=<<
this [<formlParLst>]{<intfcAccrs>}
>>

tryStatement(tryBody,catchClas,finallyBlk)::=<<
try<tryBody><if(catchClas)><catchClas><endif><if(finallyBlk)><finallyBlk><endif>
>>

catchClauses(specificCatch,generalCatch)::=<<
<specificCatch><if(generalCatch)><generalCatch><endif>
>>

catchClauses2(catchCls)::=<<
<catchCls>
>>

specificCatchClauses(clauses)::=<<
<clauses>
>>

specificCatchClause(type,typeName,body)::=<<
catch(<type> <if(typeName)><typeName><endif>)<body>
>>

generalCatchClause(body)::=<<
catch <body>
>>

finallyClause(body)::=<<
finally <body>
>>

checkedStatement(body)::=<<
checked <body>
>>

uncheckedStatement(body)::=<<
unchecked <body>
>>

forInitializer(init)::=<<
<init>
>>

forCondition(expression)::=<<
<expression>
>>

forIterator(exprList)::=<<
<exprList>
>>

statementExpressionListChld(expression)::=<<
,<expression>
>>

statementExpressionList(firstExpr,list)::=<<
<firstExpr><if(list)><list><endif>
>>

typeParameterConstraintsClauses(constraints)::=<<
<if(constraints)><constraints><endif>
>>

typeParameterConstraintsClause(whereKwd,typPar,typParConst)::=<<
<whereKwd> <typPar> : <typParConst>
>>

typeParameterConstraints(constraint)::=<<
<constraint>
>>

typeParameterConstraints2(primaryConstr,secondaryConstr,constrCon)::=<<
<primaryConstr><if(secondaryConstr)>,<secondaryConstr><endif> <if(constrCon)>,<constrCon><endif>
>>

secondaryConstraintsChld(iType)::=<<
,<iType>
>> 

secondaryConstraints(firstTyp,list)::=<<
<firstTyp><if(list)><list><endif>
>>

constantDeclarator(lhs,rhs)::=<<
<lhs> = <rhs>
>>

methodDeclaration(head,body)::=<<
<head><body>
>>

methodHeader(attributes,methodModifiers,partialKwd,retTyp,memNam,typParLst,formlParLst,typParConCls)::=<<
<if(attributes)><attributes><endif> <if(methodModifiers)><methodModifiers><endif> <if(partialKwd)><partialKwd><endif> <retTyp> <memNam> <if(typParLst)><typParLst><endif>(<if(formlParLst)><formlParLst><endif>) <typParConCls>
>>

methodModifiers(list)::=<<
<if(list)><list><endif>
>>

returnType(type)::=<<
<type>
>>

defaultArgument(expression)::=<<
=<expression>
>>

eventModifiers(list)::=<<
<if(list)><list><endif>
>>

eventDeclaration(attributes,evntModfs,type,child)::=<<
<if(attributes)><attributes><endif> <if(evntModfs)><evntModfs><endif> event <type> <child>
>>

eventDeclarationChld(varDecl)::=<<
<varDecl>;
>>

eventDeclarationChld2(memNam,evntAccDecl)::=<<
<memNam>{<evntAccDecl>}
>>

eventAccessorDeclarationsChld(kwd,body,acssDecl)::=<<
<kwd> <body> <acssDecl>
>>

addAccessorDeclaration(attributes,kwd,body)::=<<
<if(attributes)><attributes><endif> <kwd> <body>
>>

removerAccessorDeclaration(attributes,kwd,body)::=<<
<if(attributes)><attributes><endif> <kwd> <body>
>>

indexerDeclaration(attributes,modfs,indexerDecl,accsrDecl)::=<<
<if(attributes)><attributes><endif> <if(modfs)><modfs><endif> <indexerDecl>{<accsrDecl>}
>>

indexerModifiers(list)::=<<
<if(list)><list> <endif>
>>

indexerDeclarator(type,intfcTyp,formlParLst)::=<<
<type><if(intfcTyp)><intfcTyp>.<endif> this[<formlParLst>]
>>

operatorDeclaration(attributes,optrModfs,optrDecl,optrBody)::=<<
<if(attributes)><attributes><endif> <optrModfs><optrDecl><optrBody>
>>

operatorModifiers(list)::=<<
<if(list)><list><endif>
>>

eventAccessorDeclarations(attributes,child)::=<<
<if(attributes)><attributes><endif> <child>
>>

operatorDeclarator(optrDecl)::=<<
<optrDecl>
>>

unaryOperatorDeclarator(type,overldbleUnryOptr,innerTyp,name)::=<<
<type> operator <overldbleUnryOptr>(<innerTyp> <name>)
>>

binaryOperatorDeclarator(type,binryOptr,innerTyp1,innerTyp1Nam,innerTyp2,innerTyp2Nam)::=<<
<type><binryOptr>(<innerTyp1><innerTyp1Nam>,<innerTyp2><innerTyp2Nam>)
>>

conversionOperatorDeclarator(keyWrd,type1,innerType1,innerTyp1Name)::=<<
<keyWrd><type1><innerType1><innerTyp1Name>
>>

constructorDeclaration(attributes,modfs,decl,body)::=<<
<if(attributes)><attributes><endif><if(modfs)><modfs><endif><decl><body>
>>

constructorModifiers(list)::=<<
<if(list)><list><endif>
>>

constructorDeclarator(declNam,formlParLst,constrInit)::=<<
<declNam> (<if(formlParLst)><formlParLst><endif>)<constrInit>
>>

constructorInitializer(kwd,argList)::=<<
:<kwd>(<if(argList)><argList><endif>)
>>

staticConstructorDeclaration(attributes,modfs,conNam,conBody)::=<<
<if(attributes)><attributes><endif> <modfs> <conNam>()<conBody>
>>

staticConstructorModifiers(modifiers)::=<<
<modifiers>
>>

destructorDeclaration(decl)::=<<
<decl>
>>

structModifiers(list)::=<<
<if(list)><list><endif>
>>

variantTypeParameterList(params)::=<<
\<<params>\>
>>

fromContextualKeyword(value)::=<<
from <value>
>>

typeofexpression(unboundtype)::=<<
<unboundtype>
>>

unboundtypename(genericdim,genericdim1)::=<<
<genericdim><genericdim1>
>>

enumdeclaration(attr,enummod,enumbase,enumbody)::=<<
<if(attr)><attr><endif> <if(enummod)><enummod><endif> <if(enumbase)><enumbase><endif>
<enumbody>
>>

enummodifiers(enummodifier)::=<<
<enummodifier>
>>

enumbase(inttype)::=<<
<inttype>
>>

enumbody(enumbody)::=<<
<enumbody>
>>

enummemberdeclarations(enumemdec,enumemdec1)::=<<
<enumemdec><enumemdec1>
>>

enummemberdeclaration(attrib,constexpres)::=<<
<attrib><constexpres>
>>

switchstatement(expr,switchblck)::=<<
<expr><switchblck>
>>

switchblock(switchsec)::=<<
<switchsec>
>>

switchsections(switchsect,switchsect1)::=<<
<switchsect><switchsect1>
>>

switchsection(switchlabl,statmntlst)::=<<
<switchlabl><statmntlst>
>>

switchlabels(swtchlabl,swtchlabl1)::=<<
<swtchlabl><swtchlabl1>
>>

switchlabel(constntexpr)::=<<
<constntexpr>
>>

dataObjectHeader()::=<<

/**
 *************************************************************************
 NBCU CONFIDENTIAL
 ___________________

 NBCU is a trademark of NBCU Management Company.
 Copyright © 2016 NBCU. All rights reserved.

 NOTICE:  All information contained herein is, and remains
 the property of NBCU and its suppliers, if any.
 The intellectual and technical concepts contained
 herein are proprietary to NBCU and its suppliers and may be
 covered by U.S. and Foreign Patents, patents in process,
 and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from NBCU.

************************************************************************
 Author           : Generated by ATMA ®
 Revision History :
*/

package nbcu.compass.admin;

import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.apache.log4j.Logger;

>>
jasonService(methodName)::=<<
  this.<methodName> = function (data) {
   gridDataService.postData("http://localhost:8080/NBCUService/<methodName>",data,config);
   then(function(results) {
                    options.success(results);
                  }).
                  catch(function(error) {
                    options.error(error);
          
                  });
 }
>>

tsqlStatment(value)::=<<
<value>
>> 